name: Build, Test, and Deploy to EC2

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            client/package-lock.json
            server/package-lock.json

      # Test Backend
      - name: Install backend dependencies
        run: |
          cd server
          npm ci

      - name: Run backend tests
        run: |
          cd server
          npm test
        continue-on-error: false

      # Test Frontend
      - name: Install frontend dependencies
        run: |
          cd client
          npm ci

      - name: Build frontend
        run: |
          cd client
          npm run build

      - name: Run frontend tests
        run: |
          cd client
          npm test -- --coverage --watchAll=false
        continue-on-error: false

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create deployment package
        run: |
          # List files to be included (for debugging)
          echo "Files to be packaged:"
          find . -type f \
            ! -path "./node_modules/*" \
            ! -path "./.git/*" \
            ! -path "./.github/*" \
            ! -path "./coverage/*" \
            ! -path "./build/*" \
            ! -path "./dist/*" \
            ! -path "./.cache/*" \
            ! -path "./.nyc_output/*" \
            ! -name "*.log" \
            ! -name ".env.local" \
            ! -name ".DS_Store" \
            ! -name "Thumbs.db" \
            ! -name "*.tmp" \
            ! -name "*.temp" \
            ! -name ".eslintcache" \
            ! -name "junit.xml" | head -20
            
          # Create deployment archive with comprehensive exclusions
          tar -czf deployment.tar.gz \
            --warning=no-file-changed \
            --exclude='./node_modules' \
            --exclude='./client/node_modules' \
            --exclude='./server/node_modules' \
            --exclude='./.git' \
            --exclude='./.github' \
            --exclude='./coverage' \
            --exclude='./client/coverage' \
            --exclude='./server/coverage' \
            --exclude='./build' \
            --exclude='./client/build' \
            --exclude='./dist' \
            --exclude='./.cache' \
            --exclude='./.nyc_output' \
            --exclude='./.vscode' \
            --exclude='./.idea' \
            --exclude-tag-all='.gitignore' \
            --exclude='*.log' \
            --exclude='*.log.*' \
            --exclude='.env.local' \
            --exclude='.env.*.local' \
            --exclude='.DS_Store' \
            --exclude='Thumbs.db' \
            --exclude='*.tmp' \
            --exclude='*.temp' \
            --exclude='.eslintcache' \
            --exclude='junit.xml' \
            --exclude='*.tgz' \
            --exclude='*.tar.gz' \
            .
          
          # Verify archive was created and show size
          ls -lh deployment.tar.gz
          echo "Archive contents preview:"
          tar -tzf deployment.tar.gz | head -20

      - name: Configure SSH
        run: |
          set -e  # Exit immediately if any command fails
          set -x  # Print commands as they're executed (for debugging)
          
          echo "=== SSH Configuration Starting ==="
          echo "Runner OS: $RUNNER_OS"
          echo "Home directory: $HOME"
          echo "Current user: $(whoami)"
          
          # Validate required secrets
          if [ -z "${{ secrets.EC2_SSH_KEY }}" ]; then
            echo "ERROR: EC2_SSH_KEY secret is not set or empty"
            exit 1
          fi
          
          if [ -z "${{ secrets.EC2_HOST }}" ]; then
            echo "ERROR: EC2_HOST secret is not set or empty" 
            exit 1
          fi
          
          if [ -z "${{ secrets.EC2_USERNAME }}" ]; then
            echo "ERROR: EC2_USERNAME secret is not set or empty"
            exit 1
          fi
          
          echo "All required secrets are present"
          
          # Create SSH directory with proper error handling
          echo "=== Creating SSH Directory ==="
          SSH_DIR="$HOME/.ssh"
          
          if ! mkdir -p "$SSH_DIR" 2>/dev/null; then
            echo "ERROR: Failed to create SSH directory: $SSH_DIR"
            echo "Directory permissions:"
            ls -la "$HOME" || echo "Cannot list home directory"
            exit 1
          fi
          
          # Set SSH directory permissions
          if ! chmod 700 "$SSH_DIR" 2>/dev/null; then
            echo "ERROR: Failed to set permissions on SSH directory"
            ls -la "$SSH_DIR" || echo "Cannot list SSH directory"
            exit 1
          fi
          
          echo "SSH directory created successfully: $SSH_DIR"
          
          # Create SSH private key file
          echo "=== Creating SSH Private Key ==="
          SSH_KEY_FILE="$SSH_DIR/id_rsa"
          
          # Write SSH key to file
          if ! echo "${{ secrets.EC2_SSH_KEY }}" > "$SSH_KEY_FILE" 2>/dev/null; then
            echo "ERROR: Failed to write SSH key to file: $SSH_KEY_FILE"
            exit 1
          fi
          
          # Set SSH key permissions
          if ! chmod 600 "$SSH_KEY_FILE" 2>/dev/null; then
            echo "ERROR: Failed to set permissions on SSH key file"
            ls -la "$SSH_KEY_FILE" || echo "Cannot list SSH key file"
            exit 1
          fi
          
          # Verify SSH key file was created
          if [ ! -f "$SSH_KEY_FILE" ]; then
            echo "ERROR: SSH key file was not created: $SSH_KEY_FILE"
            exit 1
          fi
          
          # Check SSH key file size
          KEY_SIZE=$(stat -c%s "$SSH_KEY_FILE" 2>/dev/null || echo "0")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "ERROR: SSH key file seems too small ($KEY_SIZE bytes)"
            echo "First line of key file:"
            head -n1 "$SSH_KEY_FILE" || echo "Cannot read key file"
            exit 1
          fi
          
          echo "SSH key file created successfully ($KEY_SIZE bytes)"
          
          # Validate SSH key format
          KEY_HEADER=$(head -n1 "$SSH_KEY_FILE" 2>/dev/null || echo "")
          if [[ "$KEY_HEADER" != *"BEGIN"* ]]; then
            echo "WARNING: SSH key might not be in PEM format"
            echo "Key header: $KEY_HEADER"
          else
            echo "SSH key format appears correct"
          fi
          
          # Add EC2 host to known_hosts
          echo "=== Adding Host to known_hosts ==="
          KNOWN_HOSTS_FILE="$SSH_DIR/known_hosts"
          
          if ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> "$KNOWN_HOSTS_FILE" 2>/dev/null; then
            chmod 644 "$KNOWN_HOSTS_FILE" 2>/dev/null || echo "WARNING: Could not set known_hosts permissions"
            echo "Host added to known_hosts successfully"
          else
            echo "WARNING: Failed to add host to known_hosts (will use StrictHostKeyChecking=no)"
          fi
          
          # Final verification
          echo "=== Final SSH Setup Verification ==="
          echo "SSH directory contents:"
          ls -la "$SSH_DIR/"
          
          echo "SSH directory permissions:"
          stat -c "%a %n" "$SSH_DIR" 2>/dev/null || ls -ld "$SSH_DIR"
          
          echo "SSH key permissions:" 
          stat -c "%a %n" "$SSH_KEY_FILE" 2>/dev/null || ls -l "$SSH_KEY_FILE"
          
          # Test SSH key with ssh-keygen if available
          if command -v ssh-keygen >/dev/null 2>&1; then
            echo "=== SSH Key Validation ==="
            if ssh-keygen -l -f "$SSH_KEY_FILE" 2>/dev/null; then
              echo "SSH key validation successful"
            else
              echo "WARNING: SSH key validation failed - authentication may fail"
            fi
          fi
          
          echo "=== SSH Configuration Completed Successfully ==="

      - name: Copy files to EC2
        run: |
          echo "=== Copying deployment files to EC2 ==="
          
          # Verify SSH key exists before attempting SCP
          if [ ! -f "$HOME/.ssh/id_rsa" ]; then
            echo "ERROR: SSH private key not found at $HOME/.ssh/id_rsa"
            exit 1
          fi
          
          # Copy deployment package to EC2
          echo "Copying deployment.tar.gz to EC2 instance..."
          if ! scp -i "$HOME/.ssh/id_rsa" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            deployment.tar.gz \
            ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/; then
            echo "ERROR: Failed to copy files to EC2"
            echo "Checking SSH key permissions:"
            ls -la "$HOME/.ssh/id_rsa"
            exit 1
          fi
          
          echo "Files copied to EC2 successfully"

      - name: Deploy on EC2
        run: |
          echo "=== Deploying to EC2 ==="
          
          # Verify SSH key exists before attempting SSH
          if [ ! -f "$HOME/.ssh/id_rsa" ]; then
            echo "ERROR: SSH private key not found at $HOME/.ssh/id_rsa"
            exit 1
          fi
          
          # Connect to EC2 and deploy
          ssh -i "$HOME/.ssh/id_rsa" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
          
          # Set up deployment directory
          DEPLOY_DIR="~/task-incident-tracker"
          BACKUP_DIR="~/task-incident-tracker-backup-$(date +%Y%m%d-%H%M%S)"
          
          # Backup existing deployment if it exists
          if [ -d "$DEPLOY_DIR" ]; then
            echo "Creating backup of existing deployment..."
            cp -r "$DEPLOY_DIR" "$BACKUP_DIR"
            
            # Stop existing containers gracefully
            cd "$DEPLOY_DIR"
            docker-compose down || true
          fi
          
          # Create fresh deployment directory
          rm -rf "$DEPLOY_DIR"
          mkdir -p "$DEPLOY_DIR"
          
          # Extract new deployment
          cd "$DEPLOY_DIR"
          tar -xzf ~/deployment.tar.gz
          
          # Clean up deployment archive
          rm ~/deployment.tar.gz
          
          # Ensure Docker is running
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # Add user to docker group if not already added
          sudo usermod -aG docker $USER || true
          
          # Build and start containers
          echo "Building and starting containers..."
          docker-compose build --no-cache
          docker-compose up -d
          
          # Wait for containers to be ready
          echo "Waiting for containers to start..."
          sleep 30
          
          # Check container health
          docker-compose ps
          
          # Show logs for debugging
          echo "Container logs:"
          docker-compose logs --tail=50
          
          # Cleanup old Docker images to save space
          docker image prune -f || true
          
          # Keep only the 3 most recent backups
          ls -dt ~/task-incident-tracker-backup-* | tail -n +4 | xargs rm -rf || true
          
          echo "Deployment completed successfully!"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "=== Verifying deployment ==="
          sleep 10
          
          # Verify SSH key exists before attempting SSH
          if [ ! -f "$HOME/.ssh/id_rsa" ]; then
            echo "ERROR: SSH private key not found at $HOME/.ssh/id_rsa"
            exit 1
          fi
          
          # Test if the application is responding
          ssh -i "$HOME/.ssh/id_rsa" -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
          
          # Check if containers are running
          cd ~/task-incident-tracker
          if docker-compose ps | grep -q "Up"; then
            echo "‚úÖ Containers are running successfully"
            
            # Test API endpoint
            if curl -f -s http://localhost/api/tasks >/dev/null; then
              echo "‚úÖ API endpoint is responding"
            else
              echo "‚ö†Ô∏è  API endpoint test failed, but containers are running"
            fi
          else
            echo "‚ùå Some containers are not running properly"
            docker-compose logs --tail=20
            exit 1
          fi
          ENDSSH

      - name: Cleanup SSH
        if: always()
        run: |
          echo "=== Cleaning up SSH configuration ==="
          
          # Clean up SSH key file for security
          if [ -f "$HOME/.ssh/id_rsa" ]; then
            rm -f "$HOME/.ssh/id_rsa"
            echo "SSH private key removed"
          else
            echo "SSH private key not found (already cleaned up)"
          fi
          
          # Optionally clean up known_hosts entry
          if [ -f "$HOME/.ssh/known_hosts" ]; then
            sed -i "/${{ secrets.EC2_HOST }}/d" "$HOME/.ssh/known_hosts" 2>/dev/null || true
            echo "Host entry removed from known_hosts"
          fi
          
          echo "SSH cleanup completed"
          
  notification:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "üéâ Deployment to EC2 completed successfully!"
            echo "Your Task & Incident Tracker is now live at: http://${{ secrets.EC2_HOST }}"
          elif [ "${{ needs.test.result }}" = "failure" ]; then
            echo "‚ùå Tests failed. Deployment was skipped."
            exit 1
          else
            echo "‚ùå Deployment failed. Please check the logs."
            exit 1
          fi
